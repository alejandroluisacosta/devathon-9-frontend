[üîô Volver al README](../README.md)

# üß† Gu√≠a Avanzada de STOMP.js

Esta gu√≠a avanzada cubre el uso de la librer√≠a [`@stomp/stompjs`](https://github.com/stomp-js/stompjs) para interactuar con brokers de mensajer√≠a (RabbitMQ, ActiveMQ, etc.) mediante el protocolo STOMP sobre WebSockets. Incluye configuraci√≥n robusta, reconexi√≥n, heartbeats, manejo de errores y pr√°cticas modernas.

## Indice

- [üß† Gu√≠a Avanzada de STOMP.js](#-gu√≠a-avanzada-de-stompjs)
  - [Indice](#indice)
  - [Instalacion :blush:](#instalacion-blush)
    - [üí° Requisitos previos](#-requisitos-previos)
  - [Conexion y configuracion](#conexion-y-configuracion)
  - [Activar y desactivar el cliente STOMP](#activar-y-desactivar-el-cliente-stomp)
    - [Activar Cliente](#activar-cliente)
      - [¬øQu√© hace?](#qu√©-hace)
      - [¬øCu√°ndo lo usas?](#cu√°ndo-lo-usas)
    - [Desactivar Cliente](#desactivar-cliente)
      - [¬øQu√© hace?](#qu√©-hace-1)
      - [¬øCu√°ndo lo usas?](#cu√°ndo-lo-usas-1)
    - [Ejemplo t√≠pico](#ejemplo-t√≠pico)
  - [Suscripci√≥n a eventos](#suscripci√≥n-a-eventos)
    - [Tipos comunes de destinos](#tipos-comunes-de-destinos)
    - [Ejemplo: suscripci√≥n a canal p√∫blico](#ejemplo-suscripci√≥n-a-canal-p√∫blico)
    - [Ejemplo: suscripci√≥n a cola privada de usuario](#ejemplo-suscripci√≥n-a-cola-privada-de-usuario)
    - [Ejemplo: cancelaci√≥n de una suscripci√≥n](#ejemplo-cancelaci√≥n-de-una-suscripci√≥n)
    - [üß† Buenas pr√°cticas](#-buenas-pr√°cticas)
  - [Desuscripci√≥n a eventos](#desuscripci√≥n-a-eventos)
    - [¬øCu√°ndo deber√≠as usar .unsubscribe()?](#cu√°ndo-deber√≠as-usar-unsubscribe)
    - [üß† Buenas pr√°cticas](#-buenas-pr√°cticas-1)
  - [Env√≠o de mensajes](#env√≠o-de-mensajes)
    - [Env√≠o standar](#env√≠o-standar)
    - [Con encabezados personalizados](#con-encabezados-personalizados)
    - [Env√≠o a destinos din√°micos](#env√≠o-a-destinos-din√°micos)
    - [üß† Buenas pr√°cticas](#-buenas-pr√°cticas-2)
  - [Reintentos autom√°ticos](#reintentos-autom√°ticos)
  - [Gesti√≥n de errores](#gesti√≥n-de-errores)
  - [Ejemplo completo con @stomp/stompjs](#ejemplo-completo-con-stompstompjs)

## Instalacion :blush:

### üí° Requisitos previos

1. Un entorno con soporte para ES6 o superior.
2. Un broker de mensajer√≠a compatible con STOMP sobre WebSocket (como RabbitMQ con el plugin Web-STOMP habilitado).

```js
npm install @stomp/stompjs
```

3. üîÄ Usa sockjs-client si necesitas compatibilidad con navegadores antiguos o transporte alternativo al WebSocket nativo.

```js
npm install sockjs-client
```

## Conexion y configuracion

Para establecer una conexi√≥n b√°sica con un broker STOMP usando WebSockets, puedes crear una instancia de Client y configurar par√°metros clave como la URL del broker, encabezados de conexi√≥n, reconexi√≥n autom√°tica, y heartbeats para mantener viva la conexi√≥n.

```js
import { Client } from '@stomp/stompjs';

const client = new Client({
  //üîå URL del broker STOMP al que se conecta el cliente, usando WebSockets
  brokerURL: 'ws://localhost:15674/ws',

  //üêû Funci√≥n de depuraci√≥n: muestra en consola los logs internos del cliente STOMP.
  // √ötil para ver la conexi√≥n, suscripciones y errores.
  debug: str => console.log(`[STOMP] ${str}`),

  // üîÅ Reconexi√≥n autom√°tica: espera 5 segundos antes de intentar reconectarse si la conexi√≥n se pierde.
  reconnectDelay: 5000,

  // ‚ù§Ô∏è‚Äçüî• Heartbeats: el cliente espera y env√≠a un ‚Äúpulso‚Äù cada 10 segundos
  // Mantiene viva la conexi√≥n y detectar si el servidor cae.
  heartbeatIncoming: 10000,
  heartbeatOutgoing: 10000,

  //üîó onConnect: se ejecuta cuando el cliente se conecta
  // El objeto frame contiene informaci√≥n de los headers del servidor.
  // √ötil para confirmar la conexi√≥n o iniciar suscripciones.
  onConnect: frame => {
    console.log('‚úÖ Conectado al broker:', frame.headers);
  },

  //üõë onStompError: se dispara cuando el broker responde con un error STOMP
  // (por ejemplo, si no reconoce una ruta o hay un fallo en el backend).
  // frame.body suele incluir detalles adicionales √∫tiles para depurar.
  onStompError: frame => {
    console.error('‚ùå STOMP error:', frame.headers['message']);
    console.error('Detalles:', frame.body);
  },

  //üì¥ onDisconnect: se ejecuta cuando el cliente se desconecta.
  // √ötil para limpiar el estado de la aplicaci√≥n o mostrar alertas al usuario.
  onDisconnect: () => {
    console.warn('üîå Cliente desconectado.');
  },
});
```

## Activar y desactivar el cliente STOMP

Estas dos funciones controlan el ciclo de vida de la conexi√≥n WebSocket/STOMP. Aqu√≠ te explico:

### Activar Cliente

```js
client.activate();
```

#### ¬øQu√© hace?

1. Inicia la conexi√≥n WebSocket con el broker.
2. Realiza el handshake STOMP (CONNECT).
3. Ejecuta el callback onConnect.
4. Habilita el env√≠o/recepci√≥n de mensajes(subscriptions/publish).

#### ¬øCu√°ndo lo usas?

1. Al arrancar iniciar la conexi√≥n, manualmente o reintentos.

### Desactivar Cliente

```js
client.deactivate();
```

#### ¬øQu√© hace?

1. Env√≠a el frame DISCONNECT al broker.
2. Cierra el WebSocket.
3. Elimina todas las suscripciones activas.
4. Detiene la reconexi√≥n autom√°tica (si estaba activada).

#### ¬øCu√°ndo lo usas?

1. Al salir de un componente (por ejemplo, con useEffect en React).
2. Al cerrar sesi√≥n en tu app.
3. Si cambias de usuario o entorno.

### Ejemplo t√≠pico

```js
// Activar al iniciar
client.activate();

// Desactivar antes de cerrar o limpiar
window.addEventListener('beforeunload', () => {
  client.deactivate();
});
```

## Suscripci√≥n a eventos

STOMP.js permite suscribirse a distintos destinos que representan canales de comunicaci√≥n. Estos destinos pueden tener diferentes formas seg√∫n c√≥mo est√©n configurados en el backend (por ejemplo, en Spring WebSocket o RabbitMQ).

### Tipos comunes de destinos

- `/topic/...`: Canales p√∫blicos a los que todos los clientes pueden suscribirse. Ideal para salas de chat, notificaciones globales, etc.
- `/queue/...`: Canales punto a punto. Aunque m√∫ltiples clientes pueden suscribirse, normalmente cada mensaje solo es entregado a uno.
- `/user/queue/...`: Canales privados asociados a un usuario autenticado. Muy √∫tiles para mensajes uno-a-uno (chat privado, alertas personalizadas, etc.).

> ‚ö†Ô∏è Nota: el prefijo `/user/` es especial. El backend lo interpreta para enviar el mensaje al usuario conectado.

---

### Ejemplo: suscripci√≥n a canal p√∫blico

```ts
client.onConnect = () => {
  const subscription = client.subscribe('/topic/general', message => {
    const contenido = JSON.parse(message.body);
    console.log('Mensaje recibido en canal p√∫blico:', contenido);
  });
};
```

### Ejemplo: suscripci√≥n a cola privada de usuario

```ts
client.onConnect = () => {
  const suscripcionPrivada = client.subscribe('/user/queue/notificaciones', message => {
    const notificacion = JSON.parse(message.body);
    console.log('Notificaci√≥n privada:', notificacion);
  });
};
```

### Ejemplo: cancelaci√≥n de una suscripci√≥n

```ts
const subscription = client.subscribe('/topic/eventos', msg => {
  // procesar mensaje
});

// Cancelar la suscripci√≥n cuando ya no sea necesaria
subscription.unsubscribe();
```

### üß† Buenas pr√°cticas

- Evita m√∫ltiples suscripciones al mismo t√≥pico sin necesidad; podr√≠a duplicar la recepci√≥n de mensajes.
- Si usas React u otro framework SPA, gestiona las suscripciones en un useEffect, onMounted, o controlador de ciclo de vida adecuado.
- Siempre cancela las suscripciones cuando desmontes componentes o cierres la conexi√≥n.

## Desuscripci√≥n a eventos

El m√©todo .unsubscribe() cancela una suscripci√≥n activa que has creado previamente con .subscribe(). Despu√©s de llamarlo:

- El cliente deja de recibir mensajes de ese destino.
- Se libera la conexi√≥n asociada a esa suscripci√≥n.
- Es √∫til para evitar fugas de memoria o recibir mensajes innecesarios.

```ts
const subscription = client.subscribe('/topic/general', msg => {
  // manejar mensaje
});
```

### ¬øCu√°ndo deber√≠as usar .unsubscribe()?

- Cuando cambias de contexto de aplicaci√≥n, como cerrar sesi√≥n o cambiar de canal de chat.
- Para evitar recibir mensajes duplicados si est√°s reconfigurando suscripciones din√°micamente.

```ts
useEffect(() => {
  const sub = client.subscribe('/topic/sala', handleMessage);

  return () => {
    sub.unsubscribe();
  };
}, []);
```

### üß† Buenas pr√°cticas

- ‚úÖ Guarda siempre la referencia a la suscripci√≥n si planeas cancelarla luego.
- ‚ö†Ô∏è No llames a unsubscribe() sin haber verificado que la suscripci√≥n existe.
- ‚ö†Ô∏è Si creas m√∫ltiples suscripciones, ll√©valas en un array o en un mapa para gestionarlas limpiamente.

## Env√≠o de mensajes

El m√©todo client.publish() se utiliza para enviar mensajes al servidor STOMP a trav√©s del WebSocket. Puedes enviar mensajes a rutas espec√≠ficas (destination), con o sin encabezados personalizados (headers) y con un cuerpo (body) en texto plano o JSON.

### Env√≠o standar

```ts
client.publish({
  destination: '/app/register-user',
  body: JSON.stringify({
    name: 'manuel',
    lastname: 'entrena',
  }),
});
```

- destination: es la ruta del mensaje que debe estar definida y manejada por el servidor.
- body: contenido del mensaje. Se recomienda usar JSON.stringify() para estructurar los datos si son objetos.

### Con encabezados personalizados

```ts
client.publish({
  destination: '/app/chat',
  headers: { token: '7b5c9e1e-47f3-4b2e-b7ce-c93d04ae0e4f' },
  body: 'Mensaje importante',
});
```

üîê Importante: aunque puedes enviar tokens como encabezados STOMP, aseg√∫rate de que tu backend los valide correctamente. No es equivalente a los headers HTTP tradicionales (como Authorization), pero el servidor puede acceder a ellos desde el MessageHeaders.

### Env√≠o a destinos din√°micos

Puedes construir rutas din√°micas con variables si el backend lo permite:

```ts
client.publish({
  destination: `/app/chat/${roomId}`,
  body: JSON.stringify({ text: 'Hola sala ' + roomId }),
});
```

### üß† Buenas pr√°cticas

- ‚úÖ Serializa siempre los objetos con JSON.stringify() antes de enviarlos como cuerpo.
- ‚úÖ Documenta los headers esperados en tu backend y aseg√∫rate de que STOMP los recibe correctamente.
- ‚ö†Ô∏è No expongas datos sensibles en los headers si no est√°s usando una conexi√≥n segura (wss://).
- ‚úÖ Estandariza el esquema de mensajes para facilitar la validaci√≥n del lado servidor.
- ‚úÖ Usa encabezados para cosas como tipo de evento (eventType: 'user_joined') o trazabilidad (traceId, sessionId, etc.).

## Reintentos autom√°ticos

El par√°metro `reconnectDelay` define el tiempo entre reintentos de conexi√≥n:

```ts
reconnectDelay: 10000, // 10 segundos
```

Para gestionar errores del broker:

```ts
client.onStompError = frame => {
  console.error('STOMP error:', frame.headers['message']);
  console.error('Detalles:', frame.body);
};
```

## Gesti√≥n de errores

Errores WebSocket:

```ts
client.onWebSocketError = event => {
  console.error('WebSocket error:', event);
};
```

Errores STOMP:

```ts
client.onStompError = frame => {
  console.error('STOMP error:', frame.headers['message']);
  console.error('Detalles:', frame.body);
};
```

## Ejemplo completo con @stomp/stompjs

```ts
import { Client } from '@stomp/stompjs';

// Instancia del cliente STOMP
const client = new Client({
  brokerURL: 'ws://localhost:15674/ws',

  // Logs √∫tiles para desarrollo
  debug: str => console.log(`[STOMP DEBUG] ${str}`),

  // Reintento autom√°tico cada 5 segundos si se pierde la conexi√≥n
  reconnectDelay: 5000,

  // Heartbeats para mantener la conexi√≥n viva y detectar desconexiones
  heartbeatIncoming: 10000,
  heartbeatOutgoing: 10000,

  // Conexi√≥n exitosa
  onConnect: frame => {
    console.log('‚úÖ Conectado al broker:', frame.headers);

    // üß≠ Suscripci√≥n a canal p√∫blico
    const publicSub = client.subscribe('/topic/general', message => {
      const data = JSON.parse(message.body);
      console.log('üì£ Mensaje p√∫blico:', data);
    });

    // üîí Suscripci√≥n a cola privada de usuario
    const privateSub = client.subscribe('/user/queue/notifications', message => {
      const notif = JSON.parse(message.body);
      console.log('üîî Notificaci√≥n privada:', notif);
    });

    // üì® Env√≠o de un mensaje est√°ndar
    client.publish({
      destination: '/app/register-user',
      body: JSON.stringify({
        name: 'Manuel',
        lastname: 'Entrena',
      }),
    });

    // üì® Env√≠o de un mensaje con headers personalizados (ej. autenticaci√≥n)
    client.publish({
      destination: '/app/chat',
      headers: { token: '7b5c9e1e-47f3-4b2e-b7ce-c93d04ae0e4f' },
      body: JSON.stringify({
        message: 'Hola a todos desde el canal seguro!',
        timestamp: Date.now(),
      }),
    });

    // üßπ Cancelar suscripciones si se desea limpiar
    setTimeout(() => {
      publicSub.unsubscribe();
      privateSub.unsubscribe();
      console.log('üßπ Suscripciones canceladas tras 60 segundos');
    }, 60000);
  },

  // Error STOMP (protocolo)
  onStompError: frame => {
    console.error('‚ùå STOMP error:', frame.headers['message']);
    console.error('Detalles del error:', frame.body);
  },

  // Error WebSocket (conexi√≥n f√≠sica)
  onWebSocketError: event => {
    console.error('üö® Error WebSocket:', event);
  },

  // Desconexi√≥n
  onDisconnect: () => {
    console.warn('üîå Cliente desconectado.');
  },
});

// üîå Activar cliente
client.activate();

// üì¥ Desactivar cliente al cerrar ventana (buena pr√°ctica en SPA)
window.addEventListener('beforeunload', () => {
  client.deactivate();
});
```
